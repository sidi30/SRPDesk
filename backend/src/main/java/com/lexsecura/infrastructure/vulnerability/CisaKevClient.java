package com.lexsecura.infrastructure.vulnerability;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;

import java.time.Duration;
import java.time.LocalDate;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * CISA Known Exploited Vulnerabilities (KEV) catalog client.
 * Identifies actively exploited vulnerabilities â€” triggers CRA Art.14 24h obligation.
 */
@Component
public class CisaKevClient implements VulnerabilitySource {

    private static final Logger log = LoggerFactory.getLogger(CisaKevClient.class);
    private static final String KEV_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json";

    private final WebClient webClient;
    private final ObjectMapper objectMapper;

    // Cache: CVE -> date added (refreshed every 15 min)
    private volatile Map<String, LocalDate> kevCache = new ConcurrentHashMap<>();
    private volatile long lastRefresh = 0;
    private static final long CACHE_TTL_MS = 15 * 60 * 1000; // 15 minutes

    public CisaKevClient(ObjectMapper objectMapper) {
        this.webClient = WebClient.builder()
                .baseUrl(KEV_URL)
                .build();
        this.objectMapper = objectMapper;
    }

    @Override
    public String name() {
        return "CISA_KEV";
    }

    @Override
    public List<VulnerabilityMatch> checkCves(List<String> cveIds) {
        refreshCacheIfNeeded();
        List<VulnerabilityMatch> matches = new ArrayList<>();
        for (String cve : cveIds) {
            LocalDate dateAdded = kevCache.get(cve);
            if (dateAdded != null) {
                matches.add(new VulnerabilityMatch(
                        cve, "CISA_KEV", true, dateAdded, null, null, null, "CRITICAL",
                        "Listed in CISA KEV catalog (actively exploited)"
                ));
            }
        }
        return matches;
    }

    private synchronized void refreshCacheIfNeeded() {
        if (System.currentTimeMillis() - lastRefresh < CACHE_TTL_MS) return;
        try {
            String json = webClient.get()
                    .retrieve()
                    .bodyToMono(String.class)
                    .block(Duration.ofSeconds(30));

            JsonNode root = objectMapper.readTree(json);
            JsonNode vulns = root.get("vulnerabilities");
            if (vulns != null && vulns.isArray()) {
                Map<String, LocalDate> newCache = new ConcurrentHashMap<>();
                for (JsonNode v : vulns) {
                    String cveId = v.path("cveID").asText();
                    String dateStr = v.path("dateAdded").asText();
                    if (!cveId.isBlank()) {
                        try {
                            newCache.put(cveId, LocalDate.parse(dateStr));
                        } catch (Exception e) {
                            newCache.put(cveId, LocalDate.now());
                        }
                    }
                }
                kevCache = newCache;
                lastRefresh = System.currentTimeMillis();
                log.info("CISA KEV cache refreshed: {} CVEs", newCache.size());
            }
        } catch (Exception e) {
            log.warn("Failed to refresh CISA KEV cache: {}", e.getMessage());
        }
    }
}
