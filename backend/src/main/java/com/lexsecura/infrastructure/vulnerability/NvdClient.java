package com.lexsecura.infrastructure.vulnerability;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;

import java.math.BigDecimal;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;

/**
 * NVD (NIST National Vulnerability Database) API 2.0 client.
 * Enriches CVEs with CVSS scores and CWE data.
 */
@Component
public class NvdClient implements VulnerabilitySource {

    private static final Logger log = LoggerFactory.getLogger(NvdClient.class);
    private static final String NVD_BASE = "https://services.nvd.nist.gov/rest/json/cves/2.0";

    private final WebClient webClient;
    private final ObjectMapper objectMapper;

    public NvdClient(ObjectMapper objectMapper) {
        this.webClient = WebClient.builder().baseUrl(NVD_BASE).build();
        this.objectMapper = objectMapper;
    }

    @Override
    public String name() {
        return "NVD";
    }

    @Override
    public List<VulnerabilityMatch> checkCves(List<String> cveIds) {
        List<VulnerabilityMatch> results = new ArrayList<>();
        for (String cveId : cveIds) {
            try {
                String json = webClient.get()
                        .uri(u -> u.queryParam("cveId", cveId).build())
                        .retrieve()
                        .bodyToMono(String.class)
                        .block(Duration.ofSeconds(15));

                JsonNode root = objectMapper.readTree(json);
                JsonNode vulns = root.path("vulnerabilities");
                if (vulns.isArray() && !vulns.isEmpty()) {
                    JsonNode cve = vulns.get(0).path("cve");
                    JsonNode metrics = cve.path("metrics");

                    BigDecimal cvssScore = null;
                    String cvssVector = null;
                    String severity = null;

                    // Try CVSS 3.1 first, then 3.0, then 2.0
                    JsonNode cvss31 = metrics.path("cvssMetricV31");
                    if (cvss31.isArray() && !cvss31.isEmpty()) {
                        JsonNode cvssData = cvss31.get(0).path("cvssData");
                        cvssScore = BigDecimal.valueOf(cvssData.path("baseScore").asDouble());
                        cvssVector = cvssData.path("vectorString").asText(null);
                        severity = cvss31.get(0).path("cvssData").path("baseSeverity").asText(null);
                    }

                    if (cvssScore != null) {
                        results.add(new VulnerabilityMatch(
                                cveId, "NVD", false, null, null, cvssScore, cvssVector, severity, null
                        ));
                    }
                }
                // Rate limiting: 6 requests / 30 seconds for public API
                Thread.sleep(6000);
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt();
                break;
            } catch (Exception e) {
                log.debug("NVD lookup failed for {}: {}", cveId, e.getMessage());
            }
        }
        return results;
    }
}
