package com.lexsecura.application.service;

import com.lexsecura.application.dto.*;
import com.lexsecura.domain.model.VulnerabilityReport;
import com.lexsecura.domain.model.VulnerabilityReport.Status;
import com.lexsecura.domain.repository.VulnerabilityReportRepository;
import com.lexsecura.infrastructure.security.TenantContext;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.Year;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Service
@Transactional
public class VulnerabilityReportService {

    private static final Logger log = LoggerFactory.getLogger(VulnerabilityReportService.class);

    private final VulnerabilityReportRepository repository;
    private final AuditService auditService;
    private final Counter submittedCounter;
    private final Counter triagedCounter;

    public VulnerabilityReportService(VulnerabilityReportRepository repository,
                                       AuditService auditService,
                                       MeterRegistry meterRegistry) {
        this.repository = repository;
        this.auditService = auditService;
        this.submittedCounter = Counter.builder("cvd.reports.submitted")
                .description("Total vulnerability reports submitted")
                .register(meterRegistry);
        this.triagedCounter = Counter.builder("cvd.reports.triaged")
                .description("Total vulnerability reports triaged")
                .register(meterRegistry);
    }

    /**
     * Public submission — creates a new vulnerability report.
     * The orgId is derived from the CVD policy's product context.
     */
    public VulnerabilityReportStatusResponse submit(UUID orgId, VulnerabilityReportSubmitRequest req) {
        long seq = repository.nextTrackingSequence();
        String trackingId = "VR-" + Year.now().getValue() + "-" + String.format("%03d", seq);

        VulnerabilityReport report = VulnerabilityReport.submit(
                orgId, trackingId, req.title(), req.description(),
                req.reporterName(), req.reporterEmail(), req.anonymous());
        report.setSeverityEstimate(req.severityEstimate());
        report.setAffectedComponent(req.affectedComponent());
        report.setAffectedVersions(req.affectedVersions());
        report.setStepsToReproduce(req.stepsToReproduce());
        report.setProofOfConcept(req.proofOfConcept());
        if (req.reporterPgpFingerprint() != null) {
            report.setReporterPgpFingerprint(req.reporterPgpFingerprint());
        }

        // Default disclosure deadline: 90 days
        report.setDisclosureDeadline(Instant.now().plusSeconds(90L * 24 * 3600));

        report = repository.save(report);
        submittedCounter.increment();

        log.info("CVD report submitted: trackingId={}, orgId={}", trackingId, orgId);

        return new VulnerabilityReportStatusResponse(
                report.getTrackingId(), report.getStatus().name(),
                report.getSubmittedAt(), report.getAcknowledgedAt(),
                report.getDisclosureDeadline());
    }

    /**
     * Public status check — returns only non-sensitive fields.
     */
    @Transactional(readOnly = true)
    public VulnerabilityReportStatusResponse getStatus(String trackingId) {
        VulnerabilityReport r = repository.findByTrackingId(trackingId)
                .orElseThrow(() -> new EntityNotFoundException("Report not found: " + trackingId));
        return new VulnerabilityReportStatusResponse(
                r.getTrackingId(), r.getStatus().name(),
                r.getSubmittedAt(), r.getAcknowledgedAt(),
                r.getDisclosureDeadline());
    }

    /**
     * Internal list — all reports for the current org.
     */
    @Transactional(readOnly = true)
    public List<VulnerabilityReportResponse> listAll() {
        UUID orgId = TenantContext.getOrgId();
        return repository.findAllByOrgId(orgId).stream().map(this::toResponse).toList();
    }

    /**
     * Internal list — filtered by status.
     */
    @Transactional(readOnly = true)
    public List<VulnerabilityReportResponse> listByStatus(String statusStr) {
        UUID orgId = TenantContext.getOrgId();
        Status status = Status.valueOf(statusStr);
        return repository.findAllByOrgIdAndStatus(orgId, status).stream().map(this::toResponse).toList();
    }

    /**
     * Internal detail.
     */
    @Transactional(readOnly = true)
    public VulnerabilityReportResponse getById(UUID id) {
        UUID orgId = TenantContext.getOrgId();
        VulnerabilityReport r = repository.findByIdAndOrgId(id, orgId)
                .orElseThrow(() -> new EntityNotFoundException("Report not found: " + id));
        return toResponse(r);
    }

    /**
     * Count of NEW reports for badge display.
     */
    @Transactional(readOnly = true)
    public long countNew() {
        UUID orgId = TenantContext.getOrgId();
        return repository.countByOrgIdAndStatus(orgId, Status.NEW);
    }

    /**
     * Internal triage — workflow transition + metadata update.
     */
    public VulnerabilityReportResponse triage(UUID id, VulnerabilityReportTriageRequest req) {
        UUID orgId = TenantContext.getOrgId();
        UUID userId = TenantContext.getUserId();

        VulnerabilityReport r = repository.findByIdAndOrgId(id, orgId)
                .orElseThrow(() -> new EntityNotFoundException("Report not found: " + id));

        // Apply metadata updates
        if (req.productId() != null) r.setProductId(req.productId());
        if (req.assignedTo() != null) r.setAssignedTo(req.assignedTo());
        if (req.internalNotes() != null) r.setInternalNotes(req.internalNotes());
        if (req.internalSeverity() != null) r.setInternalSeverity(req.internalSeverity());
        if (req.cvssScore() != null) r.setCvssScore(req.cvssScore());
        if (req.cveId() != null) r.setCveId(req.cveId());

        // Apply workflow transition
        switch (req.action()) {
            case "ACKNOWLEDGE" -> r.acknowledge();
            case "START_TRIAGE" -> r.startTriage();
            case "CONFIRM" -> r.confirm();
            case "REJECT" -> r.reject(req.internalNotes());
            case "START_FIX" -> r.startFixing();
            case "MARK_FIXED" -> r.markFixed();
            case "DISCLOSE" -> r.disclose();
            default -> throw new IllegalArgumentException("Unknown action: " + req.action());
        }

        r = repository.save(r);
        triagedCounter.increment();

        auditService.record(orgId, "VULNERABILITY_REPORT", r.getId(), req.action(), userId,
                Map.of("trackingId", r.getTrackingId(), "newStatus", r.getStatus().name()));

        log.info("CVD report triaged: trackingId={}, action={}, newStatus={}",
                r.getTrackingId(), req.action(), r.getStatus());

        return toResponse(r);
    }

    /** Acknowledge a NEW report. */
    public VulnerabilityReportResponse acknowledge(UUID id) {
        return performAction(id, "ACKNOWLEDGE");
    }

    /** Start triage on an ACKNOWLEDGED report. */
    public VulnerabilityReportResponse startTriage(UUID id) {
        return performAction(id, "START_TRIAGE");
    }

    /** Confirm a vulnerability from TRIAGING. */
    public VulnerabilityReportResponse confirmReport(UUID id) {
        return performAction(id, "CONFIRM");
    }

    /** Reject a report from TRIAGING. */
    public VulnerabilityReportResponse rejectReport(UUID id, String reason) {
        UUID orgId = TenantContext.getOrgId();
        UUID userId = TenantContext.getUserId();

        VulnerabilityReport r = repository.findByIdAndOrgId(id, orgId)
                .orElseThrow(() -> new EntityNotFoundException("Report not found: " + id));

        r.reject(reason);
        r = repository.save(r);
        triagedCounter.increment();

        auditService.record(orgId, "VULNERABILITY_REPORT", r.getId(), "REJECT", userId,
                Map.of("trackingId", r.getTrackingId(), "newStatus", r.getStatus().name()));

        log.info("CVD report rejected: trackingId={}, status={}", r.getTrackingId(), r.getStatus());
        return toResponse(r);
    }

    /** Start fixing a CONFIRMED report. */
    public VulnerabilityReportResponse startFix(UUID id) {
        return performAction(id, "START_FIX");
    }

    /** Mark a FIXING report as fixed. */
    public VulnerabilityReportResponse markFixed(UUID id) {
        return performAction(id, "MARK_FIXED");
    }

    /** Disclose a FIXED or REJECTED report. */
    public VulnerabilityReportResponse discloseReport(UUID id) {
        return performAction(id, "DISCLOSE");
    }

    private VulnerabilityReportResponse performAction(UUID id, String action) {
        UUID orgId = TenantContext.getOrgId();
        UUID userId = TenantContext.getUserId();

        VulnerabilityReport r = repository.findByIdAndOrgId(id, orgId)
                .orElseThrow(() -> new EntityNotFoundException("Report not found: " + id));

        switch (action) {
            case "ACKNOWLEDGE" -> r.acknowledge();
            case "START_TRIAGE" -> r.startTriage();
            case "CONFIRM" -> r.confirm();
            case "START_FIX" -> r.startFixing();
            case "MARK_FIXED" -> r.markFixed();
            case "DISCLOSE" -> r.disclose();
            default -> throw new IllegalArgumentException("Unknown action: " + action);
        }

        r = repository.save(r);
        triagedCounter.increment();

        auditService.record(orgId, "VULNERABILITY_REPORT", r.getId(), action, userId,
                Map.of("trackingId", r.getTrackingId(), "newStatus", r.getStatus().name()));

        log.info("CVD report action: trackingId={}, action={}, newStatus={}",
                r.getTrackingId(), action, r.getStatus());
        return toResponse(r);
    }

    private VulnerabilityReportResponse toResponse(VulnerabilityReport r) {
        return new VulnerabilityReportResponse(
                r.getId(), r.getOrgId(), r.getProductId(), r.getTrackingId(),
                r.getStatus().name(),
                r.getReporterName(), r.getReporterEmail(), r.isAnonymous(),
                r.getTitle(), r.getDescription(), r.getSeverityEstimate(),
                r.getAffectedComponent(), r.getAffectedVersions(), r.getStepsToReproduce(),
                r.getAssignedTo(), r.getInternalNotes(), r.getInternalSeverity(),
                r.getCvssScore(), r.getCveId(),
                r.getSubmittedAt(), r.getAcknowledgedAt(), r.getTriagedAt(),
                r.getFixedAt(), r.getDisclosedAt(), r.getDisclosureDeadline(),
                r.getCreatedAt(), r.getUpdatedAt());
    }
}
