package com.lexsecura.application.service;

import com.lexsecura.domain.model.CraEvent;
import com.lexsecura.domain.model.Finding;
import com.lexsecura.domain.model.Vulnerability;
import com.lexsecura.domain.repository.CraEventRepository;
import com.lexsecura.domain.repository.FindingDecisionRepository;
import com.lexsecura.domain.repository.FindingRepository;
import com.lexsecura.domain.repository.ReleaseRepository;
import com.lexsecura.domain.repository.VulnerabilityRepository;
import com.lexsecura.infrastructure.vulnerability.VulnerabilityMatch;
import com.lexsecura.infrastructure.vulnerability.VulnerabilitySource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Scheduled service that enriches known vulnerabilities with data from
 * multiple external sources (CISA KEV, NVD, EUVD).
 *
 * When an actively exploited vulnerability is detected and has no NOT_AFFECTED
 * decision, a CRA Event is automatically created (Art. 14 â€” 24h obligation).
 */
@Service
public class VulnerabilityMonitorService {

    private static final Logger log = LoggerFactory.getLogger(VulnerabilityMonitorService.class);

    private final VulnerabilityRepository vulnerabilityRepository;
    private final FindingRepository findingRepository;
    private final FindingDecisionRepository findingDecisionRepository;
    private final ReleaseRepository releaseRepository;
    private final CraEventRepository craEventRepository;
    private final List<VulnerabilitySource> sources;

    public VulnerabilityMonitorService(
            VulnerabilityRepository vulnerabilityRepository,
            FindingRepository findingRepository,
            FindingDecisionRepository findingDecisionRepository,
            ReleaseRepository releaseRepository,
            CraEventRepository craEventRepository,
            List<VulnerabilitySource> sources) {
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.findingRepository = findingRepository;
        this.findingDecisionRepository = findingDecisionRepository;
        this.releaseRepository = releaseRepository;
        this.craEventRepository = craEventRepository;
        this.sources = sources;
    }

    @Scheduled(fixedDelayString = "${app.monitoring.interval-ms:21600000}")
    public void enrichVulnerabilities() {
        log.info("Starting vulnerability enrichment cycle ({} sources configured)", sources.size());

        List<Vulnerability> allVulns = vulnerabilityRepository.findAll();
        if (allVulns.isEmpty()) {
            log.info("No vulnerabilities to enrich");
            return;
        }

        // Collect CVE IDs (osvId field stores CVE identifiers)
        List<String> cveIds = allVulns.stream()
                .map(Vulnerability::getOsvId)
                .filter(id -> id != null && id.startsWith("CVE-"))
                .distinct()
                .collect(Collectors.toList());

        if (cveIds.isEmpty()) {
            log.info("No CVE-prefixed vulnerabilities to enrich");
            return;
        }

        log.info("Enriching {} CVEs across {} sources", cveIds.size(), sources.size());

        // Build index: CVE ID -> Vulnerability
        Map<String, Vulnerability> vulnByCve = allVulns.stream()
                .filter(v -> v.getOsvId() != null && v.getOsvId().startsWith("CVE-"))
                .collect(Collectors.toMap(Vulnerability::getOsvId, v -> v, (a, b) -> a));

        // Query each source and collect matches
        Map<String, List<VulnerabilityMatch>> allMatches = new HashMap<>();
        for (VulnerabilitySource source : sources) {
            try {
                log.debug("Querying source: {}", source.name());
                List<VulnerabilityMatch> matches = source.checkCves(cveIds);
                for (VulnerabilityMatch match : matches) {
                    allMatches.computeIfAbsent(match.cveId(), k -> new ArrayList<>()).add(match);
                }
                log.info("Source {} returned {} matches", source.name(), matches.size());
            } catch (Exception e) {
                log.warn("Source {} failed: {}", source.name(), e.getMessage());
            }
        }

        // Apply enrichment and track newly exploited
        int enriched = 0;
        List<Vulnerability> newlyExploited = new ArrayList<>();

        for (Map.Entry<String, List<VulnerabilityMatch>> entry : allMatches.entrySet()) {
            Vulnerability vuln = vulnByCve.get(entry.getKey());
            if (vuln == null) continue;

            boolean wasExploited = vuln.isActivelyExploited();
            applyEnrichment(vuln, entry.getValue());
            vulnerabilityRepository.save(vuln);
            enriched++;

            if (vuln.isActivelyExploited() && !wasExploited) {
                newlyExploited.add(vuln);
            }
        }

        log.info("Enrichment complete: {} vulnerabilities updated, {} newly exploited",
                enriched, newlyExploited.size());

        // Auto-create CRA events for newly exploited vulnerabilities
        for (Vulnerability vuln : newlyExploited) {
            createCraEventIfNeeded(vuln);
        }
    }

    private void applyEnrichment(Vulnerability vuln, List<VulnerabilityMatch> matches) {
        for (VulnerabilityMatch match : matches) {
            // CISA KEV: actively exploited flag
            if (match.activelyExploited()) {
                vuln.setActivelyExploited(true);
                if (match.kevDateAdded() != null) {
                    vuln.setKevDateAdded(match.kevDateAdded());
                }
            }

            // NVD: CVSS score and vector
            if (match.cvssScore() != null && (vuln.getCvssScore() == null
                    || match.cvssScore().compareTo(vuln.getCvssScore()) > 0)) {
                vuln.setCvssScore(match.cvssScore());
                vuln.setCvssVector(match.cvssVector());
            }

            // EUVD: European identifier
            if (match.euvdId() != null) {
                vuln.setEuvdId(match.euvdId());
            }

            // Severity upgrade
            if (match.severity() != null && vuln.getSeverity() == null) {
                vuln.setSeverity(match.severity());
            }
        }
    }

    private void createCraEventIfNeeded(Vulnerability vuln) {
        List<Finding> findings = findingRepository.findAllByVulnerabilityId(vuln.getId());
        if (findings.isEmpty()) return;

        for (Finding finding : findings) {
            // Skip if finding already has a NOT_AFFECTED decision
            boolean hasNotAffected = findingDecisionRepository.findAllByFindingId(finding.getId())
                    .stream()
                    .anyMatch(d -> "NOT_AFFECTED".equals(d.getDecisionType()));
            if (hasNotAffected) continue;

            // Find the release to get orgId and productId
            releaseRepository.findById(finding.getReleaseId()).ifPresent(release -> {
                CraEvent event = new CraEvent();
                event.setOrgId(release.getOrgId());
                event.setProductId(release.getProductId());
                event.setEventType("ACTIVELY_EXPLOITED_VULNERABILITY");
                event.setTitle("Actively exploited: " + vuln.getOsvId());
                event.setDescription(String.format(
                        "Vulnerability %s is listed in the CISA KEV catalog as actively exploited. "
                        + "CRA Art. 14 requires notification within 24 hours. "
                        + "CVSS: %s, Severity: %s",
                        vuln.getOsvId(),
                        vuln.getCvssScore() != null ? vuln.getCvssScore().toPlainString() : "N/A",
                        vuln.getSeverity() != null ? vuln.getSeverity() : "N/A"));
                event.setStatus("DRAFT");
                event.setDetectedAt(Instant.now());
                event.setStartedAt(Instant.now());
                event.setAutoSubmitted(false);
                event.setCreatedAt(Instant.now());
                event.setUpdatedAt(Instant.now());
                craEventRepository.save(event);

                log.warn("Auto-created CRA Event for actively exploited {} in product {}",
                        vuln.getOsvId(), release.getProductId());
            });

            // One CRA event per release is sufficient
            break;
        }
    }
}
