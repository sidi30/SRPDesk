package com.lexsecura.application.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.lexsecura.domain.model.*;
import com.lexsecura.domain.model.Component;
import com.lexsecura.domain.repository.*;
import com.lexsecura.infrastructure.osv.OsvClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.List;
import java.util.UUID;

@Service
public class VulnerabilityScanService {

    private static final Logger log = LoggerFactory.getLogger(VulnerabilityScanService.class);

    private final ReleaseRepository releaseRepository;
    private final ComponentRepository componentRepository;
    private final VulnerabilityRepository vulnerabilityRepository;
    private final FindingRepository findingRepository;
    private final OsvClient osvClient;

    public VulnerabilityScanService(
            ReleaseRepository releaseRepository,
            ComponentRepository componentRepository,
            VulnerabilityRepository vulnerabilityRepository,
            FindingRepository findingRepository,
            OsvClient osvClient) {
        this.releaseRepository = releaseRepository;
        this.componentRepository = componentRepository;
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.findingRepository = findingRepository;
        this.osvClient = osvClient;
    }

    @Scheduled(cron = "${app.osv.cron:0 0 3 * * *}")
    public void scanAll() {
        log.info("Starting scheduled vulnerability scan");
        try {
            List<Release> releases = releaseRepository.findAll();
            for (Release release : releases) {
                scanRelease(release.getId());
            }
        } catch (Exception e) {
            log.error("Vulnerability scan failed", e);
        }
        log.info("Scheduled vulnerability scan completed");
    }

    @Transactional
    public int scanRelease(UUID releaseId) {
        List<Component> components = componentRepository.findAllByReleaseId(releaseId);
        int findings = 0;

        for (Component component : components) {
            if (component.getPurl() == null) continue;

            List<JsonNode> vulns = osvClient.queryVulnerabilities(component.getPurl());
            for (JsonNode vulnNode : vulns) {
                findings += processVulnerability(releaseId, component, vulnNode);
            }
        }

        log.info("Scan complete for release {}: {} new findings", releaseId, findings);
        return findings;
    }

    private int processVulnerability(UUID releaseId, Component component, JsonNode vulnNode) {
        String osvId = vulnNode.path("id").asText(null);
        if (osvId == null) return 0;

        Vulnerability vulnerability = vulnerabilityRepository.findByOsvId(osvId)
                .orElseGet(() -> {
                    Vulnerability v = new Vulnerability();
                    v.setOsvId(osvId);
                    v.setSummary(vulnNode.path("summary").asText(null));
                    v.setDetails(truncate(vulnNode.path("details").asText(null), 5000));
                    v.setSeverity(extractSeverity(vulnNode));
                    v.setPublished(parseInstant(vulnNode.path("published").asText(null)));
                    v.setModified(parseInstant(vulnNode.path("modified").asText(null)));

                    JsonNode aliases = vulnNode.path("aliases");
                    if (aliases.isArray()) {
                        v.setAliases(aliases.toString());
                    }
                    v.setCreatedAt(Instant.now());
                    return vulnerabilityRepository.save(v);
                });

        if (findingRepository.existsByReleaseIdAndComponentIdAndVulnerabilityId(
                releaseId, component.getId(), vulnerability.getId())) {
            return 0;
        }

        Finding finding = new Finding();
        finding.setReleaseId(releaseId);
        finding.setComponentId(component.getId());
        finding.setVulnerabilityId(vulnerability.getId());
        finding.setStatus("OPEN");
        finding.setDetectedAt(Instant.now());
        finding.setSource("OSV");
        findingRepository.save(finding);

        return 1;
    }

    private String extractSeverity(JsonNode vulnNode) {
        JsonNode severity = vulnNode.path("database_specific").path("severity");
        if (severity.isTextual()) return severity.asText();

        JsonNode cvss = vulnNode.path("severity");
        if (cvss.isArray() && !cvss.isEmpty()) {
            return cvss.get(0).path("type").asText("UNKNOWN");
        }
        return "UNKNOWN";
    }

    private Instant parseInstant(String value) {
        if (value == null || value.isBlank()) return null;
        try {
            return Instant.parse(value);
        } catch (Exception e) {
            return null;
        }
    }

    private String truncate(String value, int maxLen) {
        if (value == null) return null;
        return value.length() > maxLen ? value.substring(0, maxLen) : value;
    }
}
