package com.lexsecura.application.service;

import com.lexsecura.application.dto.VulnerabilityReportStatusResponse;
import com.lexsecura.application.dto.VulnerabilityReportSubmitRequest;
import com.lexsecura.application.dto.VulnerabilityReportTriageRequest;
import com.lexsecura.application.dto.VulnerabilityReportResponse;
import com.lexsecura.domain.model.VulnerabilityReport;
import com.lexsecura.domain.repository.VulnerabilityReportRepository;
import com.lexsecura.infrastructure.security.TenantContext;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class VulnerabilityReportServiceTest {

    @Mock
    private VulnerabilityReportRepository repository;

    @Mock
    private AuditService auditService;

    private VulnerabilityReportService service;

    private final UUID orgId = UUID.randomUUID();
    private final UUID userId = UUID.randomUUID();

    @BeforeEach
    void setUp() {
        service = new VulnerabilityReportService(repository, auditService, new SimpleMeterRegistry());
        TenantContext.setOrgId(orgId);
        TenantContext.setUserId(userId);
    }

    @AfterEach
    void tearDown() {
        TenantContext.clear();
    }

    @Test
    void submit_shouldCreateReportWithTrackingId() {
        when(repository.nextTrackingSequence()).thenReturn(42L);
        when(repository.save(any(VulnerabilityReport.class))).thenAnswer(inv -> {
            VulnerabilityReport r = inv.getArgument(0);
            r.setId(UUID.randomUUID());
            return r;
        });

        VulnerabilityReportSubmitRequest req = new VulnerabilityReportSubmitRequest(
                "XSS in login form", "Reflected XSS via email parameter",
                "John Doe", "john@example.com", null, false,
                "HIGH", "login-service", "1.0-2.0",
                "1. Go to /login\n2. Enter <script> in email", null);

        VulnerabilityReportStatusResponse resp = service.submit(orgId, req);

        assertNotNull(resp);
        assertTrue(resp.trackingId().startsWith("VR-"));
        assertTrue(resp.trackingId().contains("-042"));
        assertEquals("NEW", resp.status());
        assertNotNull(resp.submittedAt());
        assertNotNull(resp.disclosureDeadline());
    }

    @Test
    void submit_anonymous_shouldNotStoreReporterInfo() {
        when(repository.nextTrackingSequence()).thenReturn(1L);
        when(repository.save(any(VulnerabilityReport.class))).thenAnswer(inv -> {
            VulnerabilityReport r = inv.getArgument(0);
            r.setId(UUID.randomUUID());
            // Verify reporter info is null for anonymous
            assertNull(r.getReporterName());
            assertNull(r.getReporterEmail());
            assertTrue(r.isAnonymous());
            return r;
        });

        VulnerabilityReportSubmitRequest req = new VulnerabilityReportSubmitRequest(
                "Buffer overflow", "Stack-based buffer overflow in parser",
                "Hidden Name", "hidden@email.com", null, true,
                "CRITICAL", null, null, null, null);

        VulnerabilityReportStatusResponse resp = service.submit(orgId, req);
        assertEquals("NEW", resp.status());
    }

    @Test
    void triage_fullWorkflow_shouldTransitionCorrectly() {
        VulnerabilityReport report = VulnerabilityReport.submit(
                orgId, "VR-2026-001", "Test vuln", "Description",
                "Reporter", "reporter@test.com", false);
        report.setId(UUID.randomUUID());

        when(repository.findByIdAndOrgId(report.getId(), orgId)).thenReturn(Optional.of(report));
        when(repository.save(any(VulnerabilityReport.class))).thenAnswer(inv -> inv.getArgument(0));

        // ACKNOWLEDGE
        VulnerabilityReportTriageRequest ack = new VulnerabilityReportTriageRequest(
                "ACKNOWLEDGE", null, userId, null, null, null, null);
        VulnerabilityReportResponse resp = service.triage(report.getId(), ack);
        assertEquals("ACKNOWLEDGED", resp.status());

        // START_TRIAGE
        VulnerabilityReportTriageRequest triage = new VulnerabilityReportTriageRequest(
                "START_TRIAGE", null, null, "Investigating", "HIGH", null, null);
        resp = service.triage(report.getId(), triage);
        assertEquals("TRIAGING", resp.status());

        // CONFIRM
        VulnerabilityReportTriageRequest confirm = new VulnerabilityReportTriageRequest(
                "CONFIRM", null, null, null, null, new java.math.BigDecimal("8.1"), "CVE-2026-1234");
        resp = service.triage(report.getId(), confirm);
        assertEquals("CONFIRMED", resp.status());

        // START_FIX
        VulnerabilityReportTriageRequest fix = new VulnerabilityReportTriageRequest(
                "START_FIX", null, null, null, null, null, null);
        resp = service.triage(report.getId(), fix);
        assertEquals("FIXING", resp.status());

        // MARK_FIXED
        VulnerabilityReportTriageRequest fixed = new VulnerabilityReportTriageRequest(
                "MARK_FIXED", null, null, null, null, null, null);
        resp = service.triage(report.getId(), fixed);
        assertEquals("FIXED", resp.status());

        // DISCLOSE
        VulnerabilityReportTriageRequest disclose = new VulnerabilityReportTriageRequest(
                "DISCLOSE", null, null, null, null, null, null);
        resp = service.triage(report.getId(), disclose);
        assertEquals("DISCLOSED", resp.status());
    }

    @Test
    void triage_invalidTransition_shouldThrow() {
        VulnerabilityReport report = VulnerabilityReport.submit(
                orgId, "VR-2026-002", "Test", "Desc", "R", "r@t.com", false);
        report.setId(UUID.randomUUID());

        when(repository.findByIdAndOrgId(report.getId(), orgId)).thenReturn(Optional.of(report));

        // Can't START_TRIAGE from NEW (must ACKNOWLEDGE first)
        VulnerabilityReportTriageRequest req = new VulnerabilityReportTriageRequest(
                "START_TRIAGE", null, null, null, null, null, null);

        assertThrows(IllegalStateException.class, () -> service.triage(report.getId(), req));
    }

    @Test
    void getStatus_existing_shouldReturnPublicFields() {
        VulnerabilityReport report = VulnerabilityReport.submit(
                orgId, "VR-2026-003", "Test", "Desc", "R", "r@t.com", false);
        report.setId(UUID.randomUUID());

        when(repository.findByTrackingId("VR-2026-003")).thenReturn(Optional.of(report));

        VulnerabilityReportStatusResponse resp = service.getStatus("VR-2026-003");
        assertEquals("VR-2026-003", resp.trackingId());
        assertEquals("NEW", resp.status());
    }

    @Test
    void getStatus_notFound_shouldThrow() {
        when(repository.findByTrackingId("VR-9999-999")).thenReturn(Optional.empty());

        assertThrows(EntityNotFoundException.class, () -> service.getStatus("VR-9999-999"));
    }
}
