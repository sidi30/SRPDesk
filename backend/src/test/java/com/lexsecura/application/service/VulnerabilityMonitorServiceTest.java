package com.lexsecura.application.service;

import com.lexsecura.domain.model.*;
import com.lexsecura.domain.repository.*;
import com.lexsecura.infrastructure.vulnerability.VulnerabilityMatch;
import com.lexsecura.infrastructure.vulnerability.VulnerabilitySource;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class VulnerabilityMonitorServiceTest {

    @Mock private VulnerabilityRepository vulnerabilityRepository;
    @Mock private FindingRepository findingRepository;
    @Mock private FindingDecisionRepository findingDecisionRepository;
    @Mock private ReleaseRepository releaseRepository;
    @Mock private CraEventRepository craEventRepository;
    @Mock private VulnerabilitySource kevSource;

    private VulnerabilityMonitorService service;

    @BeforeEach
    void setUp() {
        service = new VulnerabilityMonitorService(
                vulnerabilityRepository, findingRepository, findingDecisionRepository,
                releaseRepository, craEventRepository, List.of(kevSource));
    }

    @Test
    void enrichVulnerabilities_updatesExploitedFlag() {
        Vulnerability vuln = new Vulnerability();
        vuln.setId(UUID.randomUUID());
        vuln.setOsvId("CVE-2024-1234");
        vuln.setActivelyExploited(false);

        when(vulnerabilityRepository.findAll()).thenReturn(List.of(vuln));
        when(kevSource.name()).thenReturn("CISA_KEV");
        when(kevSource.checkCves(List.of("CVE-2024-1234"))).thenReturn(List.of(
                new VulnerabilityMatch("CVE-2024-1234", "CISA_KEV", true,
                        LocalDate.of(2024, 6, 1), null, null, null, "CRITICAL",
                        "Actively exploited")));

        // No findings so no CRA event created
        when(findingRepository.findAllByVulnerabilityId(vuln.getId())).thenReturn(List.of());
        when(vulnerabilityRepository.save(any())).thenAnswer(i -> i.getArgument(0));

        service.enrichVulnerabilities();

        ArgumentCaptor<Vulnerability> captor = ArgumentCaptor.forClass(Vulnerability.class);
        verify(vulnerabilityRepository).save(captor.capture());
        assertTrue(captor.getValue().isActivelyExploited());
        assertEquals(LocalDate.of(2024, 6, 1), captor.getValue().getKevDateAdded());
    }

    @Test
    void enrichVulnerabilities_createsCraEventForExploitedWithoutDecision() {
        Vulnerability vuln = new Vulnerability();
        vuln.setId(UUID.randomUUID());
        vuln.setOsvId("CVE-2024-5678");
        vuln.setActivelyExploited(false);

        Finding finding = new Finding();
        finding.setId(UUID.randomUUID());
        finding.setReleaseId(UUID.randomUUID());
        finding.setVulnerabilityId(vuln.getId());

        Release release = new Release();
        release.setId(finding.getReleaseId());
        release.setOrgId(UUID.randomUUID());
        release.setProductId(UUID.randomUUID());

        when(vulnerabilityRepository.findAll()).thenReturn(List.of(vuln));
        when(kevSource.name()).thenReturn("CISA_KEV");
        when(kevSource.checkCves(any())).thenReturn(List.of(
                new VulnerabilityMatch("CVE-2024-5678", "CISA_KEV", true,
                        LocalDate.now(), null, null, null, "CRITICAL", null)));
        when(vulnerabilityRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        when(findingRepository.findAllByVulnerabilityId(vuln.getId())).thenReturn(List.of(finding));
        when(findingDecisionRepository.findAllByFindingId(finding.getId())).thenReturn(List.of());
        when(releaseRepository.findById(finding.getReleaseId())).thenReturn(Optional.of(release));
        when(craEventRepository.save(any())).thenAnswer(i -> i.getArgument(0));

        service.enrichVulnerabilities();

        ArgumentCaptor<CraEvent> captor = ArgumentCaptor.forClass(CraEvent.class);
        verify(craEventRepository).save(captor.capture());
        assertEquals("ACTIVELY_EXPLOITED_VULNERABILITY", captor.getValue().getEventType());
        assertEquals("DRAFT", captor.getValue().getStatus());
        assertEquals(release.getOrgId(), captor.getValue().getOrgId());
    }

    @Test
    void enrichVulnerabilities_noCraEventWhenNotAffectedDecisionExists() {
        Vulnerability vuln = new Vulnerability();
        vuln.setId(UUID.randomUUID());
        vuln.setOsvId("CVE-2024-9999");
        vuln.setActivelyExploited(false);

        Finding finding = new Finding();
        finding.setId(UUID.randomUUID());
        finding.setReleaseId(UUID.randomUUID());
        finding.setVulnerabilityId(vuln.getId());

        FindingDecision decision = new FindingDecision();
        decision.setDecisionType("NOT_AFFECTED");

        when(vulnerabilityRepository.findAll()).thenReturn(List.of(vuln));
        when(kevSource.name()).thenReturn("CISA_KEV");
        when(kevSource.checkCves(any())).thenReturn(List.of(
                new VulnerabilityMatch("CVE-2024-9999", "CISA_KEV", true,
                        LocalDate.now(), null, null, null, "CRITICAL", null)));
        when(vulnerabilityRepository.save(any())).thenAnswer(i -> i.getArgument(0));
        when(findingRepository.findAllByVulnerabilityId(vuln.getId())).thenReturn(List.of(finding));
        when(findingDecisionRepository.findAllByFindingId(finding.getId())).thenReturn(List.of(decision));

        service.enrichVulnerabilities();

        verify(craEventRepository, never()).save(any());
    }

    @Test
    void enrichVulnerabilities_noVulns_doesNothing() {
        when(vulnerabilityRepository.findAll()).thenReturn(List.of());

        service.enrichVulnerabilities();

        verify(kevSource, never()).checkCves(any());
    }

    @Test
    void enrichVulnerabilities_appliesCvssFromNvd() {
        Vulnerability vuln = new Vulnerability();
        vuln.setId(UUID.randomUUID());
        vuln.setOsvId("CVE-2024-0001");

        when(vulnerabilityRepository.findAll()).thenReturn(List.of(vuln));
        when(kevSource.name()).thenReturn("NVD");
        when(kevSource.checkCves(any())).thenReturn(List.of(
                new VulnerabilityMatch("CVE-2024-0001", "NVD", false,
                        null, null, BigDecimal.valueOf(9.8),
                        "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                        "CRITICAL", null)));
        when(vulnerabilityRepository.save(any())).thenAnswer(i -> i.getArgument(0));

        service.enrichVulnerabilities();

        ArgumentCaptor<Vulnerability> captor = ArgumentCaptor.forClass(Vulnerability.class);
        verify(vulnerabilityRepository).save(captor.capture());
        assertEquals(BigDecimal.valueOf(9.8), captor.getValue().getCvssScore());
        assertNotNull(captor.getValue().getCvssVector());
    }
}
